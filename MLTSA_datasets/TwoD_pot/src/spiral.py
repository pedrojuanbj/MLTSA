import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from tqdm import tqdm
import sympy as spy
from math import sin, cos, tan, exp, atan2

class potential_spiral:
    """spiral potential generation class, including 3 example expressions of spiral potential with derivatives
    """
    def __init__(self, branches=2):
        """__init__ initializing the class of potential spiral

        :param branches: number of branches that the spiral branch should have, defaults to 2
        :type branches: int, optional
        """        
        # Parameters
        ## Boundary Conditions
        self.BOUNDARY = 20
        self.x_min = -self.BOUNDARY
        self.x_max = self.BOUNDARY
        self.y_min = -self.BOUNDARY
        self.y_max = self.BOUNDARY

        ## Hyper Parameters
        self.sigma = 0.35
        self.warping_coeff = 0.01
        self.decrease_coeff = 0.05 # decrease how Potential decrease when we get further from center
        self.sinus_to_distance_coeff = 0.1

        ## instantiation
        self.n_petals = branches

    def generate_function(self):
        """Generating the expression of potential function and corresponding derivatives
        """
        # Symbolic variables for symbolic expression of the potential
        x_symb, y_symb = spy.symbols('x_symb, y_symb', real=True)

        # Transform coordinates from (x, y) to (angle, Distance)
        angle_symb = spy.atan2(x_symb, y_symb)
        distance_squared_symb = x_symb ** 2 + y_symb ** 2

        # Use the chosen shape function
        r_symb = (spy.sin((angle_symb + self.warping_coeff * distance_squared_symb) * self.n_petals) *\
                 self.sinus_to_distance_coeff * distance_squared_symb + 2)

        # Apply the formula
        # Const to multi
        mul = -1
        potential_symbolic = mul*spy.exp( -1/2*(1)/(self.sigma*r_symb)**2)*(1+self.decrease_coeff*distance_squared_symb)

        # Symbolic derivatives with respect to x and y
        dpotsym_dx = potential_symbolic.diff(x_symb)
        dpotsym_dy = potential_symbolic.diff(y_symb)

        # Get the equations of potential and derivatives
        spiral_pot = str(potential_symbolic)
        spiral_dx = str(dpotsym_dx)
        spiral_dy = str(dpotsym_dy)
        print("Return in order of: potential, dx, dy")
        return spiral_pot, spiral_dx, spiral_dy

    def visualize_3d(self, ngrid=200):
        """Plotting the potential surface
        
        :param ngrid: number of grid to plot, the larger it is the more accurate the plot is, defaults to 200
        :type ngrid: int, optional
        """        

        # Meshgrid of potential surface
        [x,y] = np.meshgrid(np.linspace(-self.BOUNDARY, self.BOUNDARY, ngrid),\
                            np.linspace(-self.BOUNDARY, self.BOUNDARY, ngrid))

        # Calculatin Energy for each
        z = self.expl_2b_potential(x, y)

        #Plotting the potential Surface
        fig = plt.figure()
        ax = fig.add_subplot(projection='3d')
        ax.plot_surface(x, y, z, cmap=plt.cm.viridis, alpha=0.6)

    def expl_2b_potential(self, x, y):
        """An Example of 2d, 2-branch spiral potential function generated by symbolic expressions,\
             used for visualisation

        :param x: x input
        :type x: float
        :param y: y input
        :type y: float
        :return: potential value at point x,y
        :rtype: float
        """        

        return -(0.05*x**2 + 0.05*y**2 + 1)*np.exp(-1.02040816326531/(0.05*(x**2 + y**2)*\
                np.sin(0.02*x**2 + 0.02*y**2 + 2*np.arctan2(x, y)) + 1)**2)

    def expl_2b_dx(self, x, y):
        """An Example of 2d, 2-branch spiral derivative(wrt x) function generated by symbolic expressions,\
             used for visualisation
        :param x: x input
        :type x: float
        :param y: y input
        :type y: float
        :return: derivative of x value at point x,y
        :rtype: float
        """      
        print("Function not accelerated by numba, only used for limited visualisation,\
               to produce data pipeline please refer to other methods")
        return -0.1*x*exp(-1.02040816326531/(0.05*(x**2 + y**2)*sin(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)) + 1)**2) -\
                1.02040816326531*(-0.2*x*sin(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)) -\
                2*(0.04*x + 2*y/(x**2 + y**2))*(0.05*x**2 + 0.05*y**2)*cos(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)))*\
                (-0.05*x**2 - 0.05*y**2 - 1)*exp(-1.02040816326531/(0.05*(x**2 + y**2)*sin(0.02*x**2 + 0.02*y**2 +\
                2*atan2(x, y)) + 1)**2)/(0.05*(x**2 + y**2)*sin(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)) + 1)**3

    def expl_2b_dy(self, x, y):
        """An Example of 2d, 2-branch spiral derivative(wrt y) function generated by symbolic expressions,\
             used for visualisation
             
        :param x: x input
        :type x: float
        :param y: y input
        :type y: float
        :return: derivative of y value at point x,y
        :rtype: float
        """      
        print("Function not accelerated by numba, only used for limited visualisation,\
               to produce data pipeline please refer to other methods")
        return -0.1*y*exp(-1.02040816326531/(0.05*(x**2 + y**2)*sin(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)) + 1)**2) -\
                1.02040816326531*(-0.2*y*sin(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)) -\
                2*(0.05*x**2 + 0.05*y**2)*(-2*x/(x**2 + y**2) + 0.04*y)*cos(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)))*\
                (-0.05*x**2 - 0.05*y**2 - 1)*exp(-1.02040816326531/(0.05*(x**2 + y**2)*\
                sin(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)) + 1)**2)/(0.05*(x**2 + y**2)*\
                sin(0.02*x**2 + 0.02*y**2 + 2*atan2(x, y)) + 1)**3